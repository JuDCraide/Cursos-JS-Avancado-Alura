<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Negociações</title>
    <link rel="stylesheet" href="css/bootstrap.css" />
    <link rel="stylesheet" href="css/bootstrap-theme.css" />
  </head>

  <body class="container">
    <h1 class="text-center">Negociações</h1>

    <div id="mensagem-view"></div>

    <form class="form" onsubmit="negociacaoController.adiciona(event)">
      <div class="form-group">
        <label for="data">Data</label>
        <input type="date" id="data" class="form-control" required autofocus />
      </div>

      <div class="form-group">
        <label for="quantidade">Quantidade</label>
        <input
          type="number"
          min="1"
          step="1"
          id="quantidade"
          class="form-control"
          value="1"
          required
        />
      </div>

      <div class="form-group">
        <label for="valor">Valor</label>
        <input
          id="valor"
          type="number"
          class="form-control"
          min="0.01"
          step="0.01"
          value="0.0"
          required
        />
      </div>

      <button class="btn btn-primary" type="submit">Incluir</button>
    </form>

    <div class="text-center">
      <button class="btn btn-primary text-center" type="button">
        Importar Negociações
      </button>
      <button
        onclick="negociacaoController.apaga()"
        class="btn btn-primary text-center"
        type="button"
      >
        Apagar
      </button>
    </div>
    <br />
    <br />

    <div id="negociacoes-view"></div>

    <script src="js/app/models/Negociacao.js"></script>
    <script src="js/app/controllers/NegociacaoController.js"></script>
    <script src="js/app/helpers/DateHelper.js"></script>
    <script src="js/app/models/ListaNegociacoes.js"></script>

    <script src="js/app/views/View.js"></script>

    <script src="js/app/views/NegociacoesView.js"></script>
    <script src="js/app/models/Mensagem.js"></script>
    <script src="js/app/views/MensagemView.js"></script>
    <script>
      let negociacaoController = new NegociacaoController();
    </script>
    <script>
        //criamos um Proxy para colocar as armadilhas nele e não no modelo
        //o construtor do Proxy recebe a criação do objeto e os handlers
        let negociacao = new Proxy(new Negociacao(new Date(), 1, 100), {
            //ao chamarmos um get a função executará
            //ela recebe um target -> objeto original,
            //uma prop-> propriendade acessada
            //e o receiver -> referencia do Proxy
            get: function(target, prop, receiver) {
                    //mas só o texto foi exibido, mas o get retornou undefined
                    //console.log(`a prop ${prop} foi interceptada`)   
                    //isso ocorreu porque não infomamos o que a intercepção retorna
                    //podemos retornar qualquer coisa EX: return 'Flávio'
                    //mas para retornar o resultado do get usamos o Reflect.get()
                    return Reflect.get(target, prop ,receiver);
                    //a mensgem é impressa 2 vezes pq intercepta tanto para quantidade quanto para _quantidade
            },

            //armadila de escrita, mesmas entradas mais o value que será mudado
            set: function (target, prop, value, receiver) {
            //fazemos target[prop], pois quando prop=valor ele pega o mesmo que target.valor
            //console.log(`valor anterior: ${target[prop]}, novo valor: ${value}`);

            return Reflect.set(target, prop, value, receiver);
            },
        });
        //console.log(negociacao.quantidade);
        //console.log(negociacao.valor);

        //não devia ser feito, mas licença poética para testar set
        negociacao._quantidade = 6;
        negociacao._valor = 50;
        
    
        //agora vamos fazer o mesmo para lista q é q realmente precisamos
        let lista = new Proxy(new ListaNegociacoes(), {
            /*set: function (target, prop, value, receiver) {
            
                console.log(`valor anterior: ${target[prop]}, novo valor: ${value}`);
                return Reflect.set(target, prop, value, receiver);
            }*/

            //como set não funcionou vamos usar o get
            //podemos fazer direto set(target, prop, value, receiver) {...}
            //ao invés de get: function(target, prop, value, receiver) {...}
            //pq o get é um object literal
            get(target, prop, receiver) {
                //testamos se a prop é adiciona ou esvazia e se é uma função
                if(['adiciona','esvazia'].includes(prop) && typeof(target[prop]) == typeof(Function)){
                    //substituimos o método do objeto por outra função, sem mudar a classe
                    //tem que ser function por causa do this dinâmico
                    return function() {
                        console.log(`interceptando ${prop}`);
                        //arguments recebe um array com os argumentos passados p função
                        Reflect.apply(target[prop], target, arguments);
                    }
                }

                return Reflect.get(target, prop, receiver)
                
            }   
        });
        // o set não funcionaou para o adiciona, só funciona para esvazia
        //adiciona não funciona usando Proxy, pq ele não atribui ele faz um push
        //então podemos fazer uma gambiarra de forçar um set no model para usar o Proxy        
        lista.adiciona(new Negociacao(new Date(), 1, 100));
        lista.esvazia();
    </script>
  </body>
</html>
